<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Tree View</title>
    <style>
        ul {
            list-style-type: none;
            padding-left: 0;
            margin: 0;
        }
        li {
            margin: 0;
            padding: 5px;
            border-radius: 3px;
            display: flex;
            /* align-items: center; */
        }
        .collapsible {
            cursor: pointer;
        }
        .icon {
            margin-right: 5px;
            cursor: pointer;
            user-select: none;
        }
        .icon::before {
            content: '+';
            display: inline-block;
        }
        .collapsible.open .icon::before {
            content: '-';
        }
        .nested {
            display: none;
            padding-left: 20px; /* Ensure proper indentation for children */
        }
        .nested.show {
            display: block;
        }
        .selected {
            background-color: #b3d9ff;
        }
    </style>
</head>
<body>
    <div id="tree-container"></div>

    <script>
        const data = [
            { Id: 1, Text: "Root Node", ParentId: 0 },
            { Id: 2, Text: "Child Node 1", ParentId: 1 },
            { Id: 3, Text: "Child Node 2", ParentId: 1 },
            { Id: 4, Text: "Sub-child Node 1", ParentId: 2 },
            { Id: 5, Text: "Sub-child Node 2", ParentId: 2 }
        ];

        function buildTree(data) {
            const nodeMap = new Map();
            const rootNodes = [];

            // Create a map of all nodes
            data.forEach(node => {
                nodeMap.set(node.Id, { ...node, children: [] });
            });

            // Populate children
            data.forEach(node => {
                const currentNode = nodeMap.get(node.Id);
                if (node.ParentId === 0) {
                    rootNodes.push(currentNode);
                } else {
                    const parentNode = nodeMap.get(node.ParentId);
                    if (parentNode) {
                        parentNode.children.push(currentNode);
                    }
                }
            });

            return rootNodes;
        }

        function createTreeElement(nodes) {
            const ul = document.createElement('ul');
            nodes.forEach(node => {
                const li = document.createElement('li');
                const icon = document.createElement('span');
                icon.classList.add('icon');
                
                const textSpan = document.createElement('span');
                textSpan.textContent = node.Text;

                textSpan.addEventListener('click', function(e) {
                    e.stopPropagation();
                    document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                    this.classList.add('selected');
                    console.log('Selected node:', this.textContent);
                });

                li.appendChild(icon);
                li.appendChild(textSpan);

                if (node.children.length > 0) {
                    li.classList.add('collapsible');
                    const nestedUl = createTreeElement(node.children);
                    nestedUl.classList.add('nested');
                    li.appendChild(nestedUl);

                    icon.addEventListener('click', function(e) {
                        e.stopPropagation();
                        li.classList.toggle('open');
                        nestedUl.classList.toggle('show');
                    });
                }

                ul.appendChild(li);
            });

            return ul;
        }

        const container = document.getElementById('tree-container');
        const treeData = buildTree(data);
        container.appendChild(createTreeElement(treeData));
    </script>
</body>
</html>
